<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>cosmicBallet.MassiveObjectSimulator API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cosmicBallet.MassiveObjectSimulator</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cosmicBallet.MassiveObjectSimulator.BinaryMerger"><code class="flex name class">
<span>class <span class="ident">BinaryMerger</span></span>
<span>(</span><span>binary_system: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Class that simulates the merger of two celestial objects.</p>
<p>The class allows for the simulation of the merger of two celestial objects such as Neutron Stars or Black Holes. The
simulation is performed using the NRSur7dq2 and SurfinBH libraries for the gravitational waveforms and the final
remnant mass and spin calculations. The simulation is performed under the assumption that the two objects are in a
binary system and are in the process of merging. The simulation is performed in natural units.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>binaryBH</code></strong> :&ensp;<code>module</code></dt>
<dd>The module that contains the functions for the Binary Merger simulation.</dd>
<dt><strong><code>binary_system</code></strong> :&ensp;<code>list</code></dt>
<dd>List of two objects that are to be simulated for Binary Merger.</dd>
<dt><strong><code>q</code></strong> :&ensp;<code>float</code></dt>
<dd>The mass ratio of the two objects in the binary system.</dd>
<dt><strong><code>chi1</code></strong> :&ensp;<code>np.array</code></dt>
<dd>The dimensionless spin of the first object in the binary system.</dd>
<dt><strong><code>chi2</code></strong> :&ensp;<code>np.array</code></dt>
<dd>The dimensionless spin of the second object in the binary system.</dd>
<dt><strong><code>trajectory</code></strong> :&ensp;<code>list</code></dt>
<dd>A list that contains the trajectory of the binary systems as they merge.</dd>
<dt><strong><code>waveforms</code></strong> :&ensp;<code>dict</code></dt>
<dd>The gravitational waveforms generated by the binary system (contains multiple modes).</dd>
<dt><strong><code>time_vals</code></strong> :&ensp;<code>np.array</code></dt>
<dd>The time values for the gravitational waveforms and trajectories.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>simulate(): Calculates the trajectory of the two objects as they merge.
animate(): Visualizes the trajectory of the two objects as they merge.
gw_plot(mode): Plots the gravitational waveforms generated by the binary system.</p>
<p>Constructor for the BinaryMerger class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>binary_system</code></strong> :&ensp;<code>list</code></dt>
<dd>List of two objects that are to be simulated for Binary Merger.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>OSError</code></dt>
<dd>Raised when the Binary Merger simulation is attempted on a non-Linux system.</dd>
<dt><code>ImportError</code></dt>
<dd>Raised when the NRSur7dq2 and SurfinBH libraries are not installed.</dd>
<dt><code>TypeError</code></dt>
<dd>Raised when the binary_system is not a list, or the objects in the list are not of the same type,
or the objects are not Neutron Stars or BlackHole class.</dd>
<dt><code>ValueError</code></dt>
<dd>Raised when the binary_system does not have exactly two objects.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BinaryMerger():
    &#34;&#34;&#34;Class that simulates the merger of two celestial objects.

    The class allows for the simulation of the merger of two celestial objects such as Neutron Stars or Black Holes. The
    simulation is performed using the NRSur7dq2 and SurfinBH libraries for the gravitational waveforms and the final
    remnant mass and spin calculations. The simulation is performed under the assumption that the two objects are in a
    binary system and are in the process of merging. The simulation is performed in natural units.

    Attributes:
        binaryBH (module): The module that contains the functions for the Binary Merger simulation.
        binary_system (list): List of two objects that are to be simulated for Binary Merger.
        q (float): The mass ratio of the two objects in the binary system.
        chi1 (np.array): The dimensionless spin of the first object in the binary system.
        chi2 (np.array): The dimensionless spin of the second object in the binary system.
        trajectory (list): A list that contains the trajectory of the binary systems as they merge.
        waveforms (dict): The gravitational waveforms generated by the binary system (contains multiple modes).
        time_vals (np.array): The time values for the gravitational waveforms and trajectories.

    Methods:
        simulate(): Calculates the trajectory of the two objects as they merge.
        animate(): Visualizes the trajectory of the two objects as they merge.
        gw_plot(mode): Plots the gravitational waveforms generated by the binary system.
    &#34;&#34;&#34;
    def __init__(self, binary_system:list)-&gt;None:
        &#34;&#34;&#34;Constructor for the BinaryMerger class.

        Args:
            binary_system (list): List of two objects that are to be simulated for Binary Merger.

        Raises:
            OSError: Raised when the Binary Merger simulation is attempted on a non-Linux system.
            ImportError: Raised when the NRSur7dq2 and SurfinBH libraries are not installed.
            TypeError: Raised when the binary_system is not a list, or the objects in the list are not of the same type,
                        or the objects are not Neutron Stars or BlackHole class.
            ValueError: Raised when the binary_system does not have exactly two objects.
        &#34;&#34;&#34;
        try:
            assert platform.system()==&#34;Linux&#34;
        except AssertionError:
            raise OSError(&#34;Binary Merger simulation is only supported on Linux&#34;)
        try:
            import cosmicBallet.utils.binaryBH as binaryBH
            self.binaryBH = binaryBH
        except ImportError:
            raise ImportError(&#34;NRSur7dq2 and SurfinBH libraries are required for Binary Merger simulation&#34;)
        try:
            assert isinstance(binary_system, list), &#34;binary_system must be a list&#34;
            assert type(binary_system[0])==type(binary_system[1]), &#34;Objects in the binary_system must be of the same type&#34;
            for obj in binary_system:
                assert isinstance(obj, (Stars, BlackHole)), &#34;Objects in the binary_system must be Neutron Stars or Black Holes&#34;
                if isinstance(obj, Stars):
                    assert obj.star_type==&#34;Neutron&#34;, f&#34;{obj.name} is not a Neutron Star&#34;
        except AssertionError:
            raise TypeError
        try:
            assert len(binary_system)==2, &#34;Binary System must have only two objects&#34;
        except AssertionError:
            raise ValueError
        self.binary_system = binary_system
        self.q = binary_system[0].mass / binary_system[1].mass
        self.calculate_chi
    
    @property
    def calculate_chi(self)-&gt;None:
        &#34;&#34;&#34;Property of the BinaryMerger class that calculates the dimensionless spins of the two objects in the binary
        system.
        &#34;&#34;&#34;
        self.chi1 = const.C * self.binary_system[0].angular_momentum / (const.G * self.binary_system[0].mass**2)
        self.chi2 = const.C * self.binary_system[1].angular_momentum / (const.G * self.binary_system[1].mass**2)
    
    def simulate(self):
        &#34;&#34;&#34; Method of the BinaryMerger class that calculates the trajectory of the two objects as they merge.
        &#34;&#34;&#34;
        vals = self.binaryBH.get_binary_data(self.q, self.chi1, self.chi2, None, None, None)
        self.trajectory = [vals[5], vals[6]]
        self.waveforms = vals[4]
        self.time_vals = vals[0]

    def animate(self):
        radius_list = [self.binary_system[0].radius, self.binary_system[1].radius]
        _animate_merger(self.time_vals, self.trajectory, radius_list)

    def gw_plot(self, mode:tuple)-&gt;None:
        &#34;&#34;&#34;Method of the BinaryMerger class that plots the gravitational waveforms generated by the binary system.

        Args:
            mode (tuple): The mode of the gravitational waveforms to be plotted.
        &#34;&#34;&#34;
        import matplotlib.pyplot as plt
        try:
            assert mode in self.waveforms.keys()
        except AssertionError:
            raise ValueError(f&#34;Mode {mode} not found in the waveforms&#34;)
        hp = self.waveforms[mode].real
        hx = self.waveforms[mode].imag
        plt.plot(self.time_vals, hp, label=&#34;hp&#34;)
        plt.plot(self.time_vals, hx, label=&#34;hx&#34;)
        plt.xlabel(&#34;Time (M)&#34;)
        plt.ylabel(&#34;Strain (hr/M)&#34;)
        plt.legend()
        plt.show()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="cosmicBallet.MassiveObjectSimulator.BinaryMerger.calculate_chi"><code class="name">prop <span class="ident">calculate_chi</span></code></dt>
<dd>
<div class="desc"><p>Property of the BinaryMerger class that calculates the dimensionless spins of the two objects in the binary
system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def calculate_chi(self)-&gt;None:
    &#34;&#34;&#34;Property of the BinaryMerger class that calculates the dimensionless spins of the two objects in the binary
    system.
    &#34;&#34;&#34;
    self.chi1 = const.C * self.binary_system[0].angular_momentum / (const.G * self.binary_system[0].mass**2)
    self.chi2 = const.C * self.binary_system[1].angular_momentum / (const.G * self.binary_system[1].mass**2)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cosmicBallet.MassiveObjectSimulator.BinaryMerger.animate"><code class="name flex">
<span>def <span class="ident">animate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cosmicBallet.MassiveObjectSimulator.BinaryMerger.gw_plot"><code class="name flex">
<span>def <span class="ident">gw_plot</span></span>(<span>self, mode: tuple) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Method of the BinaryMerger class that plots the gravitational waveforms generated by the binary system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The mode of the gravitational waveforms to be plotted.</dd>
</dl></div>
</dd>
<dt id="cosmicBallet.MassiveObjectSimulator.BinaryMerger.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method of the BinaryMerger class that calculates the trajectory of the two objects as they merge.</p></div>
</dd>
</dl>
</dd>
<dt id="cosmicBallet.MassiveObjectSimulator.SchwarzschildSimulator"><code class="flex name class">
<span>class <span class="ident">SchwarzschildSimulator</span></span>
<span>(</span><span>dense_body: object, stars: list, time_step: Union[float, int], simulation_time: Union[float, int])</span>
</code></dt>
<dd>
<div class="desc"><p>Class that simulates the trajectory of stars orbiting a dense object.</p>
<p>The class allows for the orbital simulation of stars around a dense object such as a (stationary) Black Hole or a
Neutron Star by utilizing the Schwarzschild solution to Einstein's theory of General Relativity. The simulation is
performed using the Schwarzschild metric for space-time. The simulation is performed under the assumption that the
mass of the dense body is negligible compared to the mass of the stars, hence the force acting on the dense body can
be ignored.</p>
<p>For more information on Schwarzschild metric and equations of motion, please refer to the article:
- <a href="https://www.physics.usu.edu/Wheeler/GenRel/Lectures/GRNotesDecSchwarzschildGeodesicsPost.pdf">https://www.physics.usu.edu/Wheeler/GenRel/Lectures/GRNotesDecSchwarzschildGeodesicsPost.pdf</a></p>
<p>Newtonian equations of motion are used to simulate the motion of the stars. The simulation is performed using the
assumption that the stars are point masses and the dense object is a stationary Black Hole or Neutron Star, with all
calculations performed in natural units.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>dense_body</code></strong> :&ensp;<code>object</code></dt>
<dd>The Neutron Star or Black Hole object.</dd>
<dt><strong><code>stars</code></strong> :&ensp;<code>list</code></dt>
<dd>A list containing the objects for stars that are orbiting the dense body.</dd>
<dt>dt (int/float): The time step value for numerical integration.</dt>
<dt>t_end (int/float): The end time for numerical integration.</dt>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The total number of time steps in the numerical integration.</dd>
<dt><strong><code>G</code></strong> :&ensp;<code>int</code></dt>
<dd>Newton's Gravitational constant in natural units (=1).</dd>
<dt><strong><code>bh_mass</code></strong> :&ensp;<code>float</code></dt>
<dd>Mass of the Dense Body in SI Units.</dd>
<dt><strong><code>dense_body_position</code></strong> :&ensp;<code>np.array</code></dt>
<dd>The initial position of the dense body.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>solve(): Performs the numerical integration for orbital simulation.</p>
<p>Constructor for the SchwarzschildSimulator class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dense_body</code></strong> :&ensp;<code>object</code></dt>
<dd>The Neutron Star or Black Hole as an initialize object.</dd>
<dt><strong><code>stars</code></strong> :&ensp;<code>list</code></dt>
<dd>A list containing the objects for stars that are orbiting the dense body.</dd>
<dt><strong><code>time_step</code></strong> :&ensp;<code>Union[float,int]</code></dt>
<dd>The time step for numerical integration.</dd>
<dt><strong><code>simulation_time</code></strong> :&ensp;<code>Union[float,int]</code></dt>
<dd>The end time for numerical integration.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>When dense_body is not a Black Hole or Neutron Star </dd>
<dt><code>TypeError</code></dt>
<dd>When stars is not a list of stars</dd>
<dt><code>TypeError</code></dt>
<dd>When object in stars list is not a Star object or is a Neutron Star</dd>
<dt><code>TypeError</code></dt>
<dd>When time_step is not a float or int value</dd>
<dt><code>TypeError</code></dt>
<dd>When simulation_time is not a float or int value</dd>
<dt><code>ValueError</code></dt>
<dd>When time_step is not a positive value</dd>
<dt><code>ValueError</code></dt>
<dd>When simulation_time is not a positive value</dd>
<dt><code>ValueError</code></dt>
<dd>When time_step is greater than the minimum time step for the simulation</dd>
<dt><code>ValueError</code></dt>
<dd>When all star objects in Stars list have common names.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SchwarzschildSimulator():
    &#34;&#34;&#34;Class that simulates the trajectory of stars orbiting a dense object.

    The class allows for the orbital simulation of stars around a dense object such as a (stationary) Black Hole or a
    Neutron Star by utilizing the Schwarzschild solution to Einstein&#39;s theory of General Relativity. The simulation is
    performed using the Schwarzschild metric for space-time. The simulation is performed under the assumption that the
    mass of the dense body is negligible compared to the mass of the stars, hence the force acting on the dense body can
    be ignored.

    For more information on Schwarzschild metric and equations of motion, please refer to the article:
    - https://www.physics.usu.edu/Wheeler/GenRel/Lectures/GRNotesDecSchwarzschildGeodesicsPost.pdf

    Newtonian equations of motion are used to simulate the motion of the stars. The simulation is performed using the
    assumption that the stars are point masses and the dense object is a stationary Black Hole or Neutron Star, with all
    calculations performed in natural units.

    Attributes:
        dense_body (object): The Neutron Star or Black Hole object.
        stars (list): A list containing the objects for stars that are orbiting the dense body.
        dt (int/float): The time step value for numerical integration.
        t_end (int/float): The end time for numerical integration.
        n (int): The total number of time steps in the numerical integration.
        G (int): Newton&#39;s Gravitational constant in natural units (=1).
        bh_mass (float): Mass of the Dense Body in SI Units.
        dense_body_position (np.array): The initial position of the dense body.

    Methods:
        solve(): Performs the numerical integration for orbital simulation.
    &#34;&#34;&#34;
    def __init__(self, dense_body:object, stars:list, time_step:Union[float,int],
                 simulation_time:Union[float,int]) -&gt; None:
        &#34;&#34;&#34;Constructor for the SchwarzschildSimulator class.

        Args:
            dense_body (object): The Neutron Star or Black Hole as an initialize object.
            stars (list): A list containing the objects for stars that are orbiting the dense body.
            time_step (Union[float,int]): The time step for numerical integration.
            simulation_time (Union[float,int]): The end time for numerical integration.

        Raises:
            TypeError: When dense_body is not a Black Hole or Neutron Star 
            TypeError: When stars is not a list of stars
            TypeError: When object in stars list is not a Star object or is a Neutron Star
            TypeError: When time_step is not a float or int value
            TypeError: When simulation_time is not a float or int value
            ValueError: When time_step is not a positive value
            ValueError: When simulation_time is not a positive value
            ValueError: When time_step is greater than the minimum time step for the simulation
            ValueError: When all star objects in Stars list have common names.
        &#34;&#34;&#34;
        try:
            assert isinstance(dense_body, (Stars, BlackHole))
        except AssertionError:
            raise TypeError(&#34;dense_body must be a Neutron Star or Black Hole&#34;)
        try:
            assert isinstance(stars, list)
        except AssertionError:
            raise TypeError(&#34;stars must be a list of stars&#34;)
        try:
            for star in stars:
                assert isinstance(star, Stars), &#34;Object in stars must be a Star object&#34;
                assert star.star_type != &#34;Neutron&#34;, &#34;Neutron Star orbit cannot be simulated&#34;
        except AssertionError:
            raise TypeError
        try:
            assert isinstance(time_step, (int,float))
        except AssertionError:
            raise TypeError(&#34;time_step can only be a float/int value&#34;)
        try:
            assert isinstance(simulation_time, (int,float))
        except AssertionError:
            raise TypeError(&#34;simulation_time can only be a float/int value&#34;)
        try:
            assert time_step&gt;0
        except AssertionError:
            raise ValueError(&#34;time_step must be a positive value&#34;)
        try:
            assert simulation_time&gt;0
        except AssertionError:
            raise ValueError(&#34;simulation_time must be a positive value&#34;)
        min_timestep = _time_step_condition(stars, dense_body)
        try:
            assert time_step&lt;=min_timestep
        except AssertionError:
            raise ValueError(f&#34;time_step must be lesser than {min_timestep}&#34;)
        try:
            name_list = []
            for star in stars:
                name_list.append(star.name)
            assert len(name_list) == len(set(name_list))
        except AssertionError:
            raise ValueError(&#34;All star objects in Stars list must have unique names&#34;)
        self.dense_body = dense_body
        self.stars = stars
        self.dt = time_step
        self.t_end = simulation_time
        self.n = math.ceil(simulation_time / time_step)
        self.dense_body_position = _set_origin(stars, dense_body)
    
    def __convert_to_natural_units(self)-&gt;None:
        &#34;&#34;&#34;Private Method of the SchwarzschildSimulator class that converts the input values of the celestial objects
        to natural units from SI units.
        &#34;&#34;&#34;
        self.G = 1
        self.bh_mass = self.dense_body.mass
        self.bh_radius = self.dense_body.radius
        self.dense_body.mass = 1
        for star in self.stars:
            star.mass = star.mass / self.bh_mass
            star.radius *= (2 / self.bh_radius)
            star.init_position *= (2 / self.bh_radius)
            star.init_velocity *= 1 / const.C
    
    def __convert_to_SI_units(self)-&gt;None:
        &#34;&#34;&#34;Private Method of the SchwarzschildSimulator class that converts the input values of the celestial objects
        to SI units from natural units.
        &#34;&#34;&#34;
        self.dense_body.mass = self.bh_mass
        for star in self.stars:
            star.mass *= self.bh_mass
            star.radius *= 0.5*self.dense_body.radius
            star.init_position *= 0.5*self.dense_body.radius
            star.init_velocity *= const.C
            for i in range(len(star.trajectory)):
                star.trajectory[i][1:] *= 0.5*self.dense_body.radius

    def __calculate_force(self)-&gt;None:
        &#34;&#34;&#34;Private method of the SchwarzschildSimulator class that computes the total force acting on the stars as they
        orbit the central dense object.

        Raises:
            RuntimeWarning: Raised when a star is at the center of the Black Hole or when two stars collide.
        &#34;&#34;&#34;
        for star in self.stars:
            star.force[:] = 0
            r = np.linalg.norm(star.position)
            if r == 0:
                print(f&#34;{star.name} is at the center of the Black Hole&#34;)
                raise RuntimeWarning
            star.force -= self.G * star.mass * self.dense_body.mass * star.position / r**3
            correction_force = _calculate_PN1(star, self.dense_body)
            star.force += correction_force
        if len(self.stars) &gt; 1:
                for i,star1 in enumerate(self.stars): 
                    for j,star2 in enumerate(self.stars):
                        if i != j:
                            r = np.linalg.norm(star1.position - star2.position)
                            if r &lt;= 0:
                                print(f&#34;{star1.name} and {star2.name} are at the same position&#34;)
                                raise RuntimeWarning
                            n = (star1.position - star2.position) / r
                            star1.force -= self.G * star1.mass * star2.mass * n / r**2
                            correction_force = _calculate_PN1(star1, star2)
                            star1.force += correction_force

    def __forest_ruth_step(self):
        &#34;&#34;&#34;Private method of the SchwarzschildSimulator class that updates the velocity and position of all bodies being simulated
        in a time slice for the Forest-Ruth Integrator.
        &#34;&#34;&#34;
        gamma = 1 / (2 - np.cbrt(2))
        w1 = gamma / 2
        w2 = (1 - gamma) / 2
        w3 = w2
        w4 = w1
        steps = [w1, w2, w3, w4]
        for w in steps:
            for body in self.stars:
                body.position += w * body.velocity * self.dt
            self.__calculate_force()
            for i,body in enumerate(self.stars):
                body.velocity += w *self.dt * body.force / body.mass

    def solve(self)-&gt;None:
        &#34;&#34;&#34;Private method of the SchwarzschildSimulator class that performs the numerical integration for
        the ODE System using the Forest-Ruth method.
        &#34;&#34;&#34;
        try:
            for star in self.stars:
                star.trajectory = []
        except:
            pass
        self.__convert_to_natural_units()
        for i in range(self.n):
            if i == 0:
                for star in self.stars:
                    star.position = star.init_position.astype(np.float64)
                    star.velocity = star.init_velocity.astype(np.float64)
                    star.trajectory.append(np.concatenate(([(i+1)*self.dt], star.position.copy())))
            self.__forest_ruth_step()
            for star in self.stars:
                star.trajectory.append(np.concatenate(([(i+2)*self.dt], star.position.copy())))
        self.__convert_to_SI_units()
        _revert_origin(self.stars, self.dense_body, self.dense_body_position)

    def __compile_results(self)-&gt;list:
        &#34;&#34;&#34;Private method of the SchwarzschildSimulator class that compiles the results of the simulation into a list.

        Returns:
            celestial_object_list (list): A list of all celestial objects in the simulation.
        &#34;&#34;&#34;
        self.dense_body.trajectory = []
        for i in range(self.n+1):
            self.dense_body.trajectory.append(np.concatenate(([(i+1)*self.dt], self.dense_body.init_position.copy())))
        celestial_object_list = [self.dense_body]
        for star in self.stars:
            celestial_object_list.append(star)
        return celestial_object_list

    def visualize(self, visualization_type:str=&#34;scientific&#34;, save_figure:bool=False, figure_name:str=None,
                  animate:bool=False)-&gt;None:
        &#34;&#34;&#34;Method of the SchwarzschildSimulator class that visualizes the trajectory of the stars.

        The method uses the Visualize class from the Visualization module to generate the visualization of the trajectory of the 
        stars around a central dense body.

        Args:
            visualization_type (str, optional): The type of visualization the method needs to generate. Defaults to &#34;scientific&#34;.
            save_figure (bool, optional): User input to whether the generated visualization needs to be saved or not. Defaults to False.
            figure_name (str, optional): The name of the file that holds the visualization if save_figure is True. Defaults to None.
            animate (bool, optional): User input to whether the visualization needs to be animated or not. Defaults to False.
        
        Raises:
            ValueError: Raised when an unrecognized visualization type is entered.
        &#34;&#34;&#34;
        try:
            for star in self.stars:
                assert len(star.trajectory)&gt;0
        except AssertionError:
            raise ValueError(&#34;The trajectory of the celestial objects is empty. Please run the simulation first&#34;)
        celestial_objects = self.__compile_results()
        vis = Visualize(celestial_objects=celestial_objects, visualization_type=visualization_type, 
                        save_figure=save_figure, figure_name=figure_name)
        vis.visualize(animate=animate)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="cosmicBallet.MassiveObjectSimulator.SchwarzschildSimulator.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Private method of the SchwarzschildSimulator class that performs the numerical integration for
the ODE System using the Forest-Ruth method.</p></div>
</dd>
<dt id="cosmicBallet.MassiveObjectSimulator.SchwarzschildSimulator.visualize"><code class="name flex">
<span>def <span class="ident">visualize</span></span>(<span>self, visualization_type: str = 'scientific', save_figure: bool = False, figure_name: str = None, animate: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Method of the SchwarzschildSimulator class that visualizes the trajectory of the stars.</p>
<p>The method uses the Visualize class from the Visualization module to generate the visualization of the trajectory of the
stars around a central dense body.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>visualization_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The type of visualization the method needs to generate. Defaults to "scientific".</dd>
<dt><strong><code>save_figure</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>User input to whether the generated visualization needs to be saved or not. Defaults to False.</dd>
<dt><strong><code>figure_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the file that holds the visualization if save_figure is True. Defaults to None.</dd>
<dt><strong><code>animate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>User input to whether the visualization needs to be animated or not. Defaults to False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Raised when an unrecognized visualization type is entered.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cosmicBallet" href="index.html">cosmicBallet</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cosmicBallet.MassiveObjectSimulator.BinaryMerger" href="#cosmicBallet.MassiveObjectSimulator.BinaryMerger">BinaryMerger</a></code></h4>
<ul class="">
<li><code><a title="cosmicBallet.MassiveObjectSimulator.BinaryMerger.animate" href="#cosmicBallet.MassiveObjectSimulator.BinaryMerger.animate">animate</a></code></li>
<li><code><a title="cosmicBallet.MassiveObjectSimulator.BinaryMerger.calculate_chi" href="#cosmicBallet.MassiveObjectSimulator.BinaryMerger.calculate_chi">calculate_chi</a></code></li>
<li><code><a title="cosmicBallet.MassiveObjectSimulator.BinaryMerger.gw_plot" href="#cosmicBallet.MassiveObjectSimulator.BinaryMerger.gw_plot">gw_plot</a></code></li>
<li><code><a title="cosmicBallet.MassiveObjectSimulator.BinaryMerger.simulate" href="#cosmicBallet.MassiveObjectSimulator.BinaryMerger.simulate">simulate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cosmicBallet.MassiveObjectSimulator.SchwarzschildSimulator" href="#cosmicBallet.MassiveObjectSimulator.SchwarzschildSimulator">SchwarzschildSimulator</a></code></h4>
<ul class="">
<li><code><a title="cosmicBallet.MassiveObjectSimulator.SchwarzschildSimulator.solve" href="#cosmicBallet.MassiveObjectSimulator.SchwarzschildSimulator.solve">solve</a></code></li>
<li><code><a title="cosmicBallet.MassiveObjectSimulator.SchwarzschildSimulator.visualize" href="#cosmicBallet.MassiveObjectSimulator.SchwarzschildSimulator.visualize">visualize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
