"""
This module contains functions to generate binary black hole waveforms and trajectories. This script is a modified version 
of the binaryBHexp module that aims to visualize the trajectories of binary black hole mergers using matplotlib animations 
with trajectories interpolated from data generated by the NRSur7dq2 module. The original copyright and scripting is credited 
to:

copyright: Copyright (C) 2018 Vijay Varma
email: vvarma@caltech.edu
author: Vijay Varma
license: MIT
GitHub Link: https://github.com/vijayvarma392/binaryBHexp/tree/master
git clone link: https://github.com/vijayvarma392/binaryBHexp.git

"""

import numpy as np
from scipy.interpolate import UnivariateSpline, InterpolatedUnivariateSpline
import surfinBH
import NRSur7dq2

PTS_PER_ORBIT = 30

def get_uniform_in_orbits_times(t:np.array, phi_orb:np.array, PTS_PER_ORBIT:int)->np.array:
    """ Function that calculates the time array for the binary system simulation.

    Args:
        t (np.array): Time array of the simulation
        phi_orb (np.array): Orbital phase array of the simulation
        PTS_PER_ORBIT (int): Number of points per orbit

    Returns:
        t_sparse (np.array): Time array for the binary system simulation
    """
    # get numer of orbits
    n_orbits = int(abs((phi_orb[-1] - phi_orb[0])/(2*np.pi)))
    # get sparse times such that there are PTS_PER_ORBIT points in each orbit
    n_pts = int(n_orbits*PTS_PER_ORBIT)
    phi_orb_sparse = np.linspace(phi_orb[0], phi_orb[-1], n_pts)
    t_sparse = np.interp(phi_orb_sparse, phi_orb, t)
    return t_sparse

def spline_interp(newX:np.array, oldX:np.array, oldY:np.array, allowExtrapolation:bool=False)->np.array:
    """ Function that interpolates data using splines.

    Args:
        newX (np.array): New x values
        oldX (np.array): Old x values
        oldY (np.array): Old y values
        allowExtrapolation (bool): Flag to allow extrapolation
    
    Returns:
        newY (np.array): New y values
    """
    if len(oldY) != len(oldX):
        raise Exception('Lengths dont match.')
    if not allowExtrapolation:
        if np.min(newX) - np.min(oldX) < -1e-5 \
                or np.max(newX) > np.max(oldX) > 1e-5:
            print(np.min(newX), np.min(oldX), np.max(newX), np.max(oldX))
            print(np.min(newX) < np.min(oldX))
            print(np.max(newX) > np.max(oldX))
            raise Exception('Trying to extrapolate, but '\
                'allowExtrapolation=False')
    if not np.all(np.diff(oldX) > 0):
        raise Exception('oldX must have increasing values')
    # returns 0 when extrapolating
    newY = InterpolatedUnivariateSpline(oldX, oldY, ext=1)(newX)
    return newY

def get_trajectory(separation:np.array, quat_nrsur:np.array, orbphase_nrsur:np.array, bh_label:str)->np.array:
    """ Function that determines the trajectory of a component in a binary given the separation, the coprecessing frame 
    quaternion and orbital phase in the coprecessing frame.

    Args:
        separation (np.array): Separation of the binary
        quat_nrsur (np.array): Quaternion of the binary system
        orbphase_nrsur (np.array): Orbital phase of the binary system
        bh_label (str): Label of the black hole component
    """
    if bh_label == 'A':
        offset = 0
    else:
        offset = np.pi
    x_copr = separation * np.cos(orbphase_nrsur+offset)
    y_copr = separation * np.sin(orbphase_nrsur+offset)
    z_copr = np.zeros(len(x_copr))
    Bh_traj_copr = np.array([x_copr, y_copr, z_copr])
    Bh_traj = surfinBH._utils.transformTimeDependentVector(quat_nrsur, Bh_traj_copr, inverse=0)
    return Bh_traj

def get_omegaOrb_from_sparse_data(t_sparse:np.array, phiOrb_sparse:np.array)->np.array:
    """ Function that computes orbital frequency from sparse data using splines.

    Args:
        t_sparse (np.array): Sparse time array
        phiOrb_sparse (np.array): Sparse orbital phase array
    
    Returns:
        omegaOrb_spl (np.array): Orbital frequency array
    """
    phiOrb_spl = UnivariateSpline(t_sparse, phiOrb_sparse, s=0)
    omegaOrb_spl = phiOrb_spl.derivative()
    return omegaOrb_spl(t_sparse)

def get_separation_from_omega(omega:np.array, mA:float, mB:float, chiA:np.array,
                               chiB:np.array, LHat:np.array, pnorder:float=3.5)->np.array:
    """ Function that calculates the separation of the binary system from the orbital frequency and other parameters.

        The separation from omega is not scientifically verified and is only used for visualization purposes (original 
        author's note).

    Args:
        omega (np.array): Orbital frequency array
        mA (float): Mass of component A
        mB (float): Mass of component B
        chiA (np.array): Spin of component A
        chiB (np.array): Spin of component B
        LHat (np.array): Angular Momentum unit vector
        pnorder (float): Post-Newtonian order (defaults to 3.5 PN)
    
    Returns:
        r (np.array): Separation array
    """
    eta = mA*mB
    deltaM = mA - mB
    Sigma_vec = mB*chiB - mA*chiA
    S_vec = mA**2.*chiA + mB**2.*chiB
    chiAB = np.sum(chiA*chiB, axis=1)
    SigmaL = np.sum(Sigma_vec*LHat, axis=1)
    SL = np.sum(S_vec*LHat, axis=1)
    x = omega**(2./3.)
    gamma_by_x = 0
    if pnorder >= 0:
        gamma_by_x += 1
    if pnorder >= 1:
        gamma_by_x += x * (1. - 1./3 *eta)
    if pnorder >= 1.5:
        gamma_by_x += x**(3./2) * (5./3 * SL + deltaM * SigmaL )
    if pnorder >= 2:
        gamma_by_x += x**2 * (1 - 65./12 *eta)
    if pnorder >= 2.5:
        gamma_by_x += x**(5./2) * ( (10./3 + 8./9 * eta)*SL \
            + 2* deltaM * SigmaL)
    if pnorder >= 3:
        gamma_by_x += x**3 * (1. + (-2203./2520 -41./192 * np.pi**2)*eta \
                + 229./36 * eta**2 + 1./81 * eta**3)
    if pnorder >= 3.5:
        gamma_by_x += x**(7./2) * ( (5 - 127./12 *eta - 6 * eta**2)*SL + \
                deltaM * SigmaL * (3 - 61./6 *eta - 8./3 * eta**2) )
    r = 1./gamma_by_x/x
    if pnorder >= 2:
        r += omega**(-2./3) * (-1./2 * eta * chiAB) * omega**(4./3)
    return r

def get_binary_data(q:float, chiA:np.array, chiB:np.array, omega_ref:np.array, omega_start:np.array=None,
        uniform_time_step_size:int=None)->tuple:
    """Function that generates binary black hole waveforms and trajectories.

    Args:
        q (float): mass ratio
        chiA (np.array): dimensionless spin of object A
        chiB (np.array): dimensionless spin of object B
        omega_ref (np.array): reference frequency
        omega_start (np.array, optional): start frequency. Defaults to None.
        uniform_time_step_size (int, optional): uniform time step size. Defaults to None.

    Returns:
        tuple: Trajectories and waveforms of the binary system
    """
    mA = q/(1.+q)
    mB = 1./(1.+q)
    nr_sur = NRSur7dq2.NRSurrogate7dq2()
    # If omega_ref is not given, set f_ref to None, and t_ref to -100
    f_ref = None if omega_ref is None else omega_ref/np.pi
    t_ref = -100 if omega_ref is None else None
    # get NRSur dynamics
    quat_nrsur, orbphase_nrsur, _, _ = nr_sur.get_dynamics(q, chiA, chiB,omega_ref=omega_ref, t_ref=t_ref, 
                                                           allow_extrapolation=True)
    if uniform_time_step_size is None:
        t_binary = get_uniform_in_orbits_times(nr_sur.tds, orbphase_nrsur, PTS_PER_ORBIT)
    else:
        t_binary = np.arange(nr_sur.tds[0], nr_sur.tds[-1], \
            uniform_time_step_size)
    # If t=0 is not in t_binary, add it
    if np.min(np.abs(t_binary - 0)) > 0.1:
        t_binary = np.sort(np.append(t_binary, 0))
    # interpolate dynamics on to t_binary
    quat_nrsur = np.array([spline_interp(t_binary, nr_sur.tds, tmp) \
        for tmp in quat_nrsur])
    orbphase_nrsur = spline_interp(t_binary, nr_sur.tds, orbphase_nrsur)
    omega_nrsur = get_omegaOrb_from_sparse_data(t_binary, orbphase_nrsur)
    h_nrsur, chiA_nrsur, chiB_nrsur = nr_sur(q, chiA, chiB, \
        f_ref=f_ref, t_ref=t_ref, return_spins=True, \
        allow_extrapolation=True, t=t_binary)
    LHat = surfinBH._utils.lHat_from_quat(quat_nrsur).T
    separation = get_separation_from_omega(omega_nrsur, mA, mB, chiA_nrsur, \
        chiB_nrsur, LHat)
    # Newtonian
    LMag = q/(1.+q)**2 * omega_nrsur**(-1./3)
    L = LHat*LMag[:, None]
    # Get component trajectories
    BhA_traj = get_trajectory(separation * mB, quat_nrsur, orbphase_nrsur, 'A')
    BhB_traj = get_trajectory(separation * mA, quat_nrsur, orbphase_nrsur, 'B')
    # If omega_start is given, retain only higher frequencies
    if omega_start is not None:
        start_idx = np.argmin(np.abs(omega_nrsur - omega_start))
        t_binary = t_binary[start_idx:]
        chiA_nrsur = chiA_nrsur[start_idx:]
        chiB_nrsur = chiB_nrsur[start_idx:]
        L = L[start_idx:]
        BhA_traj = BhA_traj.T[start_idx:].T
        BhB_traj = BhB_traj.T[start_idx:].T
        separation = separation[start_idx:]
        for key in h_nrsur.keys():
            h_nrsur[key] = h_nrsur[key][start_idx:]
    return t_binary, chiA_nrsur, chiB_nrsur, L, h_nrsur, BhA_traj, \
        BhB_traj, separation